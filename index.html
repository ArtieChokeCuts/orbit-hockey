<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Orbit Hockey</title>

  <!-- Mobile + full-viewport -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="theme-color" content="#000000" />

  <!-- Optional: reduce caching pain on GH Pages -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    #wrap {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      background: #000;
      touch-action: none;
    }

    canvas {
      position: absolute;
      inset: 0;
      width: 100vw;
      height: 100vh;
      display: block;
    }

    #hud {
      position: absolute;
      inset: 0;
      pointer-events: none;
      color: rgba(255,255,255,0.92);
      padding: 16px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    #topRow {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 12px;
      font-weight: 700;
      font-size: 14px;
      opacity: 0.95;
      text-shadow: 0 1px 2px rgba(0,0,0,0.7);
    }

    #titleRow {
      margin-top: 6px;
      font-weight: 800;
      font-size: 18px;
      opacity: 0.95;
      text-shadow: 0 1px 2px rgba(0,0,0,0.7);
    }

    #statusRow {
      margin-top: auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      font-weight: 700;
      font-size: 12px;
      opacity: 0.85;
      text-shadow: 0 1px 2px rgba(0,0,0,0.7);
    }

    #centerPrompt {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      pointer-events: none;
      color: rgba(255,255,255,0.96);
      text-shadow: 0 2px 10px rgba(0,0,0,0.85);
      letter-spacing: 0.10em;
      text-transform: uppercase;
    }

    #centerPrompt .big {
      font-size: 22px;
      font-weight: 900;
      margin-bottom: 10px;
    }

    #centerPrompt .small {
      font-size: 12px;
      font-weight: 700;
      opacity: 0.85;
    }

    #fsHint {
      position: absolute;
      right: 14px;
      bottom: 14px;
      font-size: 11px;
      opacity: 0.65;
      pointer-events: none;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
  </style>
</head>

<body>
  <div id="wrap">
    <canvas id="bg"></canvas>
    <canvas id="game"></canvas>

    <div id="hud">
      <div id="topRow">
        <div><span id="scoreL">0</span> // <span id="scoreR">0</span></div>
        <div>Altitude: <span id="altitude">0</span> mi</div>
      </div>

      <div id="titleRow">Orbit Hockey</div>

      <div id="statusRow">
        <div id="stateText">Stalling</div>
        <div id="tipsText">Tap/Click to Launch</div>
      </div>
    </div>

    <div id="centerPrompt">
      <div class="big" id="promptBig">Initiate Link</div>
      <div class="small" id="promptSmall">First to 10 • Tap anywhere</div>
    </div>

    <div id="fsHint">First tap enters fullscreen (if supported)</div>
  </div>

<script>
(() => {
  // ======== DOM ========
  const bgCanvas = document.getElementById("bg");
  const gameCanvas = document.getElementById("game");
  const bg = bgCanvas.getContext("2d");
  const g  = gameCanvas.getContext("2d");

  const scoreL = document.getElementById("scoreL");
  const scoreR = document.getElementById("scoreR");
  const altitudeEl = document.getElementById("altitude");
  const stateText = document.getElementById("stateText");
  const tipsText = document.getElementById("tipsText");
  const promptBig = document.getElementById("promptBig");
  const promptSmall = document.getElementById("promptSmall");
  const centerPrompt = document.getElementById("centerPrompt");

  // ======== Game State ========
  const state = {
    mode: "menu", // menu | playing | gameover
    left: 0,
    right: 0,
    altitude: 0,
    winScore: 10,
    time: 0
  };

  // ======== DPI + Resize ========
  let W = 0, H = 0, DPR = 1;

  // ======== Entities (defined BEFORE fit now) ========
  const puck = { x: 0, y: 0, vx: 0, vy: 0, r: 10 };
  const paddleL = { x: 0, y: 0, vx: 0, vy: 0, r: 44 };
  const paddleR = { x: 0, y: 0, vx: 0, vy: 0, r: 44 };

  // ======== Physics (base values, DPR applied in fit) ========
  const PHYS = {
    airDrag: 0.995,
    puckDrag: 0.992,
    paddleDrag: 0.90,
    bounce: 0.98,
    wallBounce: 0.96,
    maxSpeed: 24,        // *DPR set in fit
    nudge: 0.10,         // *DPR set in fit
    orbitPull: 0.00035   // *DPR set in fit
  };

  // ======== Starfield ========
  const stars = [];
  function initStars() {
    stars.length = 0;
    const count = Math.floor((W * H) / (16000 * DPR));
    for (let i = 0; i < count; i++) {
      stars.push({
        x: Math.random() * W,
        y: Math.random() * H,
        z: 0.2 + Math.random() * 0.8,
        r: (0.6 + Math.random() * 1.3) * DPR
      });
    }
  }

  function fit() {
    DPR = Math.max(1, window.devicePixelRatio || 1);
    W = Math.floor(window.innerWidth * DPR);
    H = Math.floor(window.innerHeight * DPR);

    for (const c of [bgCanvas, gameCanvas]) {
      if (c.width !== W || c.height !== H) {
        c.width = W;
        c.height = H;
      }
    }

    // DPR-scaled sizes
    puck.r = 10 * DPR;
    paddleL.r = 44 * DPR;
    paddleR.r = 44 * DPR;

    // DPR-scaled physics
    PHYS.maxSpeed = 24 * DPR;
    PHYS.nudge = 0.10 * DPR;
    PHYS.orbitPull = 0.00035 * DPR;

    initStars();
  }

  window.addEventListener("resize", fit);
  window.addEventListener("orientationchange", () => setTimeout(fit, 160));
  fit();

  // ======== Fullscreen (gesture required) ========
  async function requestFS() {
    const el = document.documentElement;
    try {
      if (document.fullscreenElement) return;
      if (el.requestFullscreen) await el.requestFullscreen();
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    } catch (_) {}
  }

  // ======== Input ========
  const input = { x: 0, y: 0, down: false };

  function pointerPos(e) {
    const rect = gameCanvas.getBoundingClientRect();
    const cx = (e.clientX - rect.left);
    const cy = (e.clientY - rect.top);
    input.x = cx * DPR;
    input.y = cy * DPR;
  }

  function onDown(e) {
    pointerPos(e);
    input.down = true;
    requestFS();

    if (state.mode === "menu" || state.mode === "gameover") startMatch();
    e.preventDefault?.();
  }
  function onMove(e) { pointerPos(e); e.preventDefault?.(); }
  function onUp(e) { input.down = false; e.preventDefault?.(); }

  window.addEventListener("pointerdown", onDown, { passive: false });
  window.addEventListener("pointermove", onMove, { passive: false });
  window.addEventListener("pointerup", onUp, { passive: false });

  // ======== Particles ========
  const sparks = [];
  function addSparks(x, y, n=14) {
    for (let i=0;i<n;i++) {
      sparks.push({
        x, y,
        vx: (Math.random()*2-1) * 7*DPR,
        vy: (Math.random()*2-1) * 7*DPR,
        life: 18 + Math.random()*12
      });
    }
  }

  // ======== Core ========
  function resetPositions() {
    puck.x = W/2; puck.y = H/2;
    puck.vx = (Math.random() < 0.5 ? -1 : 1) * (7*DPR);
    puck.vy = (Math.random()*2-1) * (4*DPR);

    paddleL.x = W*0.28; paddleL.y = H/2;
    paddleL.vx = 0; paddleL.vy = 0;

    paddleR.x = W*0.72; paddleR.y = H/2;
    paddleR.vx = 0; paddleR.vy = 0;
  }

  function startMatch() {
    state.left = 0;
    state.right = 0;
    state.altitude = 0;
    state.mode = "playing";
    centerPrompt.style.display = "none";
    stateText.textContent = "Engaged";
    tipsText.textContent = "Drag on your side";
    resetPositions();
  }

  function endMatch(winner) {
    state.mode = "gameover";
    centerPrompt.style.display = "block";
    promptBig.textContent = "Match Concluded";
    promptSmall.textContent = `${winner.toUpperCase()} WINS • Tap anywhere to restart`;
    stateText.textContent = "Override";
    tipsText.textContent = "Tap to Restart";
  }

  // ======== Starfield draw ========
  function drawStarfield() {
    bg.clearRect(0,0,W,H);

    const grd = bg.createRadialGradient(
      W*0.5, H*0.5, Math.min(W,H)*0.05,
      W*0.5, H*0.5, Math.max(W,H)*0.65
    );
    grd.addColorStop(0, "rgba(10,18,32,0.85)");
    grd.addColorStop(1, "rgba(0,0,0,0.95)");
    bg.fillStyle = grd;
    bg.fillRect(0,0,W,H);

    const driftX = Math.sin(state.time*0.00025) * 0.18 * DPR;
    const driftY = Math.cos(state.time*0.00022) * 0.14 * DPR;

    bg.fillStyle = "rgba(255,255,255,0.9)";
    for (const s of stars) {
      s.x += driftX * (0.6 + s.z);
      s.y += driftY * (0.6 + s.z);

      if (s.x < -10) s.x = W+10;
      if (s.x > W+10) s.x = -10;
      if (s.y < -10) s.y = H+10;
      if (s.y > H+10) s.y = -10;

      bg.globalAlpha = 0.35 + 0.55*s.z;
      bg.beginPath();
      bg.arc(s.x, s.y, s.r, 0, Math.PI*2);
      bg.fill();
    }
    bg.globalAlpha = 1;
  }

  // ======== Rendering ========
  function drawField() {
    g.clearRect(0,0,W,H);

    const cx = W/2, cy = H/2;
    const radius = Math.min(W,H)*0.36;

    g.save();
    g.globalAlpha = 0.28;
    g.lineWidth = 10 * DPR;
    g.strokeStyle = "rgba(80,180,255,0.95)";
    g.beginPath();
    g.arc(cx, cy, radius, 0, Math.PI*2);
    g.stroke();

    g.globalAlpha = 0.18;
    g.lineWidth = 3 * DPR;
    g.strokeStyle = "rgba(255,255,255,0.9)";
    g.beginPath();
    g.arc(cx, cy, radius*0.82, 0, Math.PI*2);
    g.stroke();

    g.globalAlpha = 0.20;
    g.fillStyle = "rgba(255,255,255,1)";
    g.beginPath();
    g.arc(cx, cy, 3*DPR, 0, Math.PI*2);
    g.fill();

    // center divider
    g.globalAlpha = 0.16;
    g.setLineDash([10*DPR, 12*DPR]);
    g.lineWidth = 2 * DPR;
    g.strokeStyle = "rgba(255,255,255,0.9)";
    g.beginPath();
    g.moveTo(W/2, 0);
    g.lineTo(W/2, H);
    g.stroke();
    g.setLineDash([]);

    g.restore();
    g.globalAlpha = 1;
  }

  function drawPaddle(p, side) {
    g.save();

    const glow = side === "L"
      ? "rgba(80,180,255,0.80)"
      : "rgba(255,120,190,0.75)";

    const fill = side === "L"
      ? "rgba(140,220,255,0.92)"
      : "rgba(255,170,220,0.90)";

    g.shadowColor = glow;
    g.shadowBlur = 22 * DPR;

    g.fillStyle = fill;
    g.beginPath();
    g.arc(p.x, p.y, p.r, 0, Math.PI*2);
    g.fill();

    g.shadowBlur = 0;
    g.globalAlpha = 0.30;
    g.strokeStyle = "rgba(0,0,0,0.88)";
    g.lineWidth = 2*DPR;
    g.beginPath();
    g.arc(p.x, p.y, p.r*0.72, 0, Math.PI*2);
    g.stroke();

    g.restore();
    g.globalAlpha = 1;
  }

  function drawPuck() {
    g.save();
    g.shadowColor = "rgba(255,255,255,0.65)";
    g.shadowBlur = 18 * DPR;

    g.fillStyle = "rgba(255,255,255,0.95)";
    g.beginPath();
    g.arc(puck.x, puck.y, puck.r, 0, Math.PI*2);
    g.fill();

    g.shadowBlur = 0;
    g.globalAlpha = 0.22;
    g.strokeStyle = "rgba(80,180,255,0.9)";
    g.lineWidth = 2*DPR;
    g.beginPath();
    g.arc(puck.x, puck.y, puck.r*0.65, 0, Math.PI*2);
    g.stroke();

    g.restore();
    g.globalAlpha = 1;
  }

  function drawSparks() {
    g.save();
    for (const s of sparks) {
      g.globalAlpha = Math.max(0, Math.min(1, s.life/30));
      g.fillStyle = "rgba(255,255,255,1)";
      g.beginPath();
      g.arc(s.x, s.y, 1.6*DPR, 0, Math.PI*2);
      g.fill();
    }
    g.restore();
    g.globalAlpha = 1;
  }

  // ======== Physics helpers ========
  function applyDrag(obj, drag) { obj.vx *= drag; obj.vy *= drag; }

  function clampSpeed(obj) {
    const sp = Math.hypot(obj.vx, obj.vy);
    if (sp > PHYS.maxSpeed) {
      const k = PHYS.maxSpeed / sp;
      obj.vx *= k; obj.vy *= k;
    }
  }

  function softOrbitPull(obj) {
    const cx = W/2, cy = H/2;
    const dx = cx - obj.x;
    const dy = cy - obj.y;
    obj.vx += dx * PHYS.orbitPull;
    obj.vy += dy * PHYS.orbitPull;
  }

  function collideCircle(a, b) {
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.hypot(dx, dy);
    const minDist = a.r + b.r;

    if (dist > 0 && dist < minDist) {
      const nx = dx / dist;
      const ny = dy / dist;
      const overlap = (minDist - dist);

      b.x += nx * overlap;
      b.y += ny * overlap;

      const relVx = b.vx - a.vx;
      const relVy = b.vy - a.vy;
      const dot = relVx*nx + relVy*ny;

      if (dot < 0) {
        b.vx -= (1 + PHYS.bounce) * dot * nx;
        b.vy -= (1 + PHYS.bounce) * dot * ny;
        addSparks(b.x, b.y, 10);
      }
    }
  }

  // ======== AI + Controls (simple air-hockey back-and-forth) ========
  function updateAIPaddle() {
    const pad = 10*DPR;
    const minX = W/2 + paddleR.r + pad;
    const maxX = W - paddleR.r - pad;

    const targetX = Math.max(minX, Math.min(maxX, puck.x));
    const targetY = Math.max(paddleR.r + pad, Math.min(H - paddleR.r - pad, puck.y));

    const aiFollow = 0.0026; // higher = harder
    const aiDrag = 0.88;

    paddleR.vx += (targetX - paddleR.x) * aiFollow;
    paddleR.vy += (targetY - paddleR.y) * aiFollow;

    applyDrag(paddleR, aiDrag);

    paddleR.x += paddleR.vx;
    paddleR.y += paddleR.vy;

    paddleR.x = Math.max(minX, Math.min(maxX, paddleR.x));
    paddleR.y = Math.max(paddleR.r + pad, Math.min(H - paddleR.r - pad, paddleR.y));
  }

  function updatePaddles() {
    if (state.mode !== "playing") return;

    const pad = 10*DPR;
    const minX = paddleL.r + pad;
    const maxX = W/2 - paddleL.r - pad;

    const tx = Math.max(minX, Math.min(maxX, input.x));
    const ty = Math.max(paddleL.r + pad, Math.min(H - paddleL.r - pad, input.y));

    const playerFollow = 0.0065;

    paddleL.vx += (tx - paddleL.x) * playerFollow;
    paddleL.vy += (ty - paddleL.y) * playerFollow;

    applyDrag(paddleL, 0.82);

    paddleL.x += paddleL.vx;
    paddleL.y += paddleL.vy;

    paddleL.x = Math.max(minX, Math.min(maxX, paddleL.x));
    paddleL.y = Math.max(paddleL.r + pad, Math.min(H - paddleL.r - pad, paddleL.y));

    updateAIPaddle();
  }

  // ======== Scoring ========
  function checkScore() {
    const goalBand = 28 * DPR;

    if (puck.x < goalBand) {
      state.right++;
      scoreR.textContent = state.right;
      resetPositions();
    } else if (puck.x > W - goalBand) {
      state.left++;
      scoreL.textContent = state.left;
      resetPositions();
    }

    if (state.left >= state.winScore) endMatch("left");
    if (state.right >= state.winScore) endMatch("right");
  }

  // ======== Loop ========
  let last = performance.now();
  function tick(now) {
    const dt = Math.min(34, now - last);
    last = now;
    state.time = now;

    drawStarfield();

    if (state.mode === "menu") {
      drawField();
      puck.x = W/2 + Math.sin(now*0.0012)*120*DPR;
      puck.y = H/2 + Math.cos(now*0.0011)*70*DPR;
      drawPuck();

      promptBig.textContent = "Initiate Link";
      promptSmall.textContent = "First to 10 • Tap anywhere";
      stateText.textContent = "Stalling";
      tipsText.textContent = "Tap/Click to Launch";
      altitudeEl.textContent = Math.floor(state.altitude);
      centerPrompt.style.display = "block";
      requestAnimationFrame(tick);
      return;
    }

    if (state.mode === "playing") {
      updatePaddles();

      // Puck float + drag + orbit
      softOrbitPull(puck);
      applyDrag(puck, PHYS.puckDrag);

      puck.x += puck.vx;
      puck.y += puck.vy;

      // Wall bounce
      if (puck.y < puck.r) { puck.y = puck.r; puck.vy = Math.abs(puck.vy) * PHYS.wallBounce; }
      if (puck.y > H - puck.r) { puck.y = H - puck.r; puck.vy = -Math.abs(puck.vy) * PHYS.wallBounce; }

      collideCircle(paddleL, puck);
      collideCircle(paddleR, puck);

      clampSpeed(puck);

      // gentle nudge (keeps your “float-control feel” without playing itself)
      for (const p of [paddleL, paddleR]) {
        const dx = puck.x - p.x;
        const dy = puck.y - p.y;
        const d = Math.hypot(dx, dy);
        if (d > 0 && d < p.r * 2.6) {
          puck.vx += (dx/d) * PHYS.nudge * 0.03;
          puck.vy += (dy/d) * PHYS.nudge * 0.03;
        }
      }

      // Sparks update
      for (let i = sparks.length - 1; i >= 0; i--) {
        const s = sparks[i];
        s.life -= 1;
        s.x += s.vx;
        s.y += s.vy;
        s.vx *= PHYS.airDrag;
        s.vy *= PHYS.airDrag;
        if (s.life <= 0) sparks.splice(i, 1);
      }

      checkScore();

      state.altitude += (Math.abs(puck.vx) + Math.abs(puck.vy)) * 0.0009;
      altitudeEl.textContent = Math.floor(state.altitude);

      drawField();
      drawPaddle(paddleL, "L");
      drawPaddle(paddleR, "R");
      drawPuck();
      drawSparks();

      stateText.textContent = "Engaged";
      tipsText.textContent = "Drag on your side";
    }

    if (state.mode === "gameover") {
      drawField();
      drawPaddle(paddleL, "L");
      drawPaddle(paddleR, "R");
      drawPuck();
      drawSparks();
    }

    requestAnimationFrame(tick);
  }

  // Boot
  resetPositions();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
