<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbit Hockey 3D</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        #ui {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: #00ffff; font-size: 24px; pointer-events: none; z-index: 10;
            text-shadow: 0 0 10px #00ffff;
        }
        #instructions {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: rgba(0, 255, 255, 0.5); font-size: 14px; z-index: 10;
        }
    </style>
</head>
<body>

<div id="ui">
    YOU: <span id="player-score">0</span> | CPU: <span id="cpu-score">0</span><br>
    <small>ALTITUDE: <span id="altitude">0</span> MI</small>
</div>
<div id="instructions">MOVE MOUSE/FINGER TO CONTROL MALLET | FIRST TO 10 WINS</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/**
 * ORBIT HOCKEY 3D - ARTIECHOKE SPECIAL
 * Features: Procedural 3D Environment, AI Opponent, Atmospheric Ascent
 */

// --- Global State ---
let playerScore = 0, cpuScore = 0, altitude = 0;
const goalTarget = 10;
const clock = new THREE.Clock();

// --- Scene Setup ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio);
document.body.appendChild(renderer.domElement);

// --- Lighting ---
const ambient = new THREE.AmbientLight(0x404040, 2);
const spotLight = new THREE.SpotLight(0xffffff, 1);
spotLight.position.set(0, 50, 0);
scene.add(ambient, spotLight);

// --- Floating Table (Procedural Glass/Metal) ---
const tableGroup = new THREE.Group();
const tableGeo = new THREE.BoxGeometry(12, 0.4, 22);
const tableMat = new THREE.MeshPhysicalMaterial({
    color: 0x111111,
    metalness: 0.9,
    roughness: 0.1,
    transmission: 0.3, // Glass effect
    thickness: 2
});
const tableMesh = new THREE.Mesh(tableGeo, tableMat);
tableGroup.add(tableMesh);

// Court Lines (Neon)
const lineMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
const centerLine = new THREE.Mesh(new THREE.PlaneGeometry(12, 0.1), lineMat);
centerLine.rotation.x = -Math.PI / 2;
centerLine.position.y = 0.21;
tableGroup.add(centerLine);

scene.add(tableGroup);

// --- The Earth (Bottom View) ---
const earthGeo = new THREE.SphereGeometry(200, 64, 64);
const earthMat = new THREE.MeshStandardMaterial({
    color: 0x1133ff,
    emissive: 0x001144,
    wireframe: true // Looks cool and digital
});
const earth = new THREE.Mesh(earthGeo, earthMat);
earth.position.y = -400;
scene.add(earth);

// --- Game Objects ---
const puck = new THREE.Mesh(
    new THREE.CylinderGeometry(0.6, 0.6, 0.3, 32),
    new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 2 })
);
puck.position.y = 0.4;
scene.add(puck);

const playerMallet = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.6, 32), new THREE.MeshStandardMaterial({ color: 0x0000ff }));
const cpuMallet = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.6, 32), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
playerMallet.position.set(0, 0.5, 9);
cpuMallet.position.set(0, 0.5, -9);
scene.add(playerMallet, cpuMallet);

// --- Physics State ---
let puckVel = { x: 0, z: 0 };
const mouse = new THREE.Vector2();

// --- Input ---
window.addEventListener('mousemove', (e) => {
    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
    mouse.z = (e.clientY / window.innerHeight) * 2 - 1;
    
    // Move mallet based on mouse, lock to bottom half
    playerMallet.position.x = mouse.x * 6;
    playerMallet.position.z = Math.max(0.5, mouse.z * 11);
});

// --- Core Logic ---
function resetPuck() {
    puck.position.set(0, 0.4, 0);
    puckVel = { x: (Math.random() - 0.5) * 0.2, z: 0.15 };
    document.getElementById('player-score').innerText = playerScore;
    document.getElementById('cpu-score').innerText = cpuScore;
}

function updatePhysics() {
    puck.position.x += puckVel.x;
    puck.position.z += puckVel.z;

    // Wall Bounces
    if (Math.abs(puck.position.x) > 5.5) puckVel.x *= -1.05;

    // Goal Check
    if (Math.abs(puck.position.z) > 11) {
        if (Math.abs(puck.position.x) < 2.5) {
            puck.position.z > 0 ? cpuScore++ : playerScore++;
            resetPuck();
        } else {
            puckVel.z *= -1.05;
        }
    }

    // Mallet Collisions (Circle-to-Circle)
    [playerMallet, cpuMallet].forEach(m => {
        const dx = puck.position.x - m.position.x;
        const dz = puck.position.z - m.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        if (dist < 1.6) {
            const angle = Math.atan2(dz, dx);
            const force = 0.25;
            puckVel.x = Math.cos(angle) * force;
            puckVel.z = Math.sin(angle) * force;
        }
    });

    // AI Logic
    const cpuSpeed = 0.08 + (playerScore * 0.01); // Gets harder
    if (puck.position.z < 0) {
        if (cpuMallet.position.x < puck.position.x) cpuMallet.position.x += cpuSpeed;
        if (cpuMallet.position.x > puck.position.x) cpuMallet.position.x -= cpuSpeed;
    }
}

function updateAscent() {
    altitude = (playerScore + cpuScore) * 50 + (Date.now() % 1000 / 100);
    document.getElementById('altitude').innerText = Math.floor(altitude);

    // Dynamic Camera (The Ascent)
    camera.position.y = 12 + (altitude / 100);
    camera.position.z = 12 + (altitude / 200);
    camera.lookAt(0, 0, 0);
    
    // Earth Rotation
    earth.rotation.y += 0.001;
    earth.position.y = -400 - (altitude * 2);
}

function animate() {
    if (playerScore >= goalTarget || cpuScore >= goalTarget) {
        document.getElementById('ui').innerHTML = playerScore >= goalTarget ? "YOU CONQUERED THE ORBIT" : "SYSTEM OVERRIDE: CPU WINS";
        return;
    }
    
    requestAnimationFrame(animate);
    updatePhysics();
    updateAscent();
    renderer.render(scene, camera);
}

// --- Start ---
resetPuck();
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
